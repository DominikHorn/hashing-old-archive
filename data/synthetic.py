import random


# -------------------------------------
#   Synthetic dataset generation code
# -------------------------------------

def write_dataset(name, numbers, amount, bytes_per_number=8):
    """
    Writes a list of numbers in our simple binary dataset format

    :param name: name of the dataset, will be used to derive filename as <name>_<bits_per_number>.ds
    :param numbers: generator for the dataset
    :param amount: how many numbers to write from generator
    :param bytes_per_number: how many bytes per number we should use for encoding. Defaults to 8
    :return:
    """
    # write payload to file (buffered 16MB chunks)
    filename = f"{name}_{bytes_per_number * 8}.ds"
    buffering = 16 * 1024 * 1024

    with open(filename, 'wb', buffering=buffering) as file:
        # header contains the amount of elements in the list (8 bytes in little endian)
        file.write(amount.to_bytes(8, byteorder='little'))

        # properly encoded bytestream from input numbers
        def byte_stream():
            n = 0
            for e in numbers:
                if n < amount:
                    yield e.to_bytes(bytes_per_number, byteorder='little')
                    n += 1
                else:
                    break

        # payload contains all numbers consecutively stored in little endian,
        # each taking up exactly bytes_per_number bytes. Write out in 256 MB chunks
        file.writelines(byte_stream())


# dense keys, e.g., autogenerated, consecutive primary keys without deletion
def dense(start=1):
    """
    Dense numbers, i.e., consecutive natural numbers. This distribution
    simulates primary keys without deletions.

    :param start: first number to occur in the dataset. Defaults to 1.
    :return:
    """
    num = start
    while True:
        yield num
        num += 1


# monotone keys, i.e., autogenerated primary keys with random missing elements/gaps, i.e., to simulate deletes
def gapped(start=1, delete_chance=0.3):
    for i in dense(start=start):
        if random.randint(1, 100) < delete_chance * 100:
            yield i


# write datasets
n = 200 * (10 ** 6)
write_dataset(name="dense", numbers=dense(start=1), amount=n, bytes_per_number=8)
write_dataset(name="dense", numbers=dense(start=1), amount=n, bytes_per_number=4)
write_dataset(name="gapped", numbers=gapped(start=1, delete_chance=0.3), amount=n, bytes_per_number=8)
